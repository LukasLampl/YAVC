package Encoder;

import java.util.ArrayList;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

import Main.config;

public class VectorEngine {
	/*
	 * Purpose: Get the MovementVectors between two frames and removes a match from the differences
	 * Return Type: ArrayList<Vector> => Movement vectors
	 * Params: ArrayList<MakroBlock> diff => Differences between the first and second frame (MakroBlocks to span the vectors from)
	 */
	public ArrayList<Vector> calculate_movement_vectors(ArrayList<MakroBlock> prevFrameBlocks, ArrayList<MakroBlock> diff) {
		int threads = Runtime.getRuntime().availableProcessors();
		ExecutorService executor = Executors.newFixedThreadPool(threads);
		
		ArrayList<Vector> vectors = new ArrayList<Vector>(diff.size());
		ArrayList<Future<Vector>> fvecs = new ArrayList<Future<Vector>>(vectors.size());
		
		for (MakroBlock block : diff) {
			Callable<Vector> task = () -> {
				MakroBlock mostEqual = get_most_equal_MakroBlock(block, prevFrameBlocks);
				Vector vec = null;
				
				if (mostEqual != null) {
					vec = new Vector();
					vec.setAppendedBlock(block);
					vec.setMostEqualBlock(mostEqual);
					vec.setStartingPoint(mostEqual.getPosition());
					vec.setSpanX(block.getPosition().x - mostEqual.getPosition().x);
					vec.setSpanY(block.getPosition().y - mostEqual.getPosition().y);
				}
				
				return vec;
			};
			
			fvecs.add(executor.submit(task));
		}
		
		for (Future<Vector> f : fvecs) {
			try {
				Vector vec = f.get();
				
				if (vec != null) {
					vectors.add(vec);
					diff.remove(vec.getAppendedBlock());
				}
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
		
		executor.shutdown();
		
		return vectors;
	}
	
	
	private MakroBlock get_most_equal_MakroBlock(MakroBlock blockToBeSearched, ArrayList<MakroBlock> diff) {
		MakroBlock mostEqual = null;
		int lowestSAD = Integer.MAX_VALUE;
		int searchRange = 4; //Range in Blocks x + searchRange; x - searchRange; y + searchRange; y - searchRange;
		
		int minX = blockToBeSearched.getPosition().x - (config.MAKRO_BLOCK_SIZE * searchRange);
		int maxX = blockToBeSearched.getPosition().x + (config.MAKRO_BLOCK_SIZE * searchRange);
		int minY = blockToBeSearched.getPosition().y - (config.MAKRO_BLOCK_SIZE * searchRange);
		int maxY = blockToBeSearched.getPosition().y + (config.MAKRO_BLOCK_SIZE * searchRange);

		for (MakroBlock block : diff) {
			int posX = block.getPosition().x;
			int posY = block.getPosition().y;
			
			if (posX < minX
				&& posY < minY) {
				continue;
			} else if (posX > maxX
				&& posY > maxY) {
				break;
			} else if (posX > maxX
				|| posY > maxY) {
				continue;
			}
			
			int SAD = get_SAD_of_colors(blockToBeSearched.getColors(), block.getColors());
			
			if (SAD < lowestSAD) {
				lowestSAD = SAD;
				mostEqual = block;
			}
		}
		
		return mostEqual;
	}
	/*
	 * Purpose: Calculate the equality between an array of colors (in Integer form)
	 * Return Type: int => Equality; The lower the more equal the colors; -1 = out of tolerance
	 * Params: int[][] colors1 => List 1 of int colors;
	 * 			int[][] colors2 => Second list of int colors
	 */
	public int get_SAD_of_colors(int[][] colors1, int[][] colors2) {
		int res = 0;
		int tolerance = 6;
		
		for (int y = 0; y < colors2.length; y++) {
			for (int x = 0; x < colors1.length; x++) {
				int prevCol = colors1[y][x];
				int curCol = colors2[y][x];
				
				int prevRed = (prevCol >> 16) & 0xFF;
				int prevGreen = (prevCol >> 8) & 0xFF;
				int prevBlue = prevCol & 0xFF;
				
				int curRed = (curCol >> 16) & 0xFF;
				int curGreen = (curCol >> 8) & 0xFF;
				int curBlue = curCol & 0xFF;
				
				int deltaRed = Math.abs(prevRed - curRed);
				int deltaGreen = Math.abs(prevGreen - curGreen);
				int deltaBlue = Math.abs(prevBlue - curBlue);
				
				if (deltaRed > tolerance
					|| deltaGreen > tolerance
					|| deltaBlue > tolerance) {
					return Integer.MAX_VALUE;
				}
				
				res += deltaRed + deltaGreen + deltaBlue;
			}
		}
		
		return res;
	}
}